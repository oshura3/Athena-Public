#!/usr/bin/env python3
"""
athena.core.diagnostic_relay
============================
Protocol 500: Self-Diagnostic Feedback Relay

Captures framework errors, sanitizes PII, and generates structured
GitHub issue drafts for human-in-the-loop submission.

Philosophy: Federated Telemetry with Sovereignty (Privacy-First).
"""

import platform
import re
import traceback
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, Optional

# --- Configuration ---


def _find_project_root() -> Path:
    """
    Find project root by searching for .athena_root marker or pyproject.toml.
    Falls back to CWD if not found.
    """
    # Start from current working directory
    current = Path.cwd().resolve()
    for parent in [current] + list(current.parents):
        if (parent / ".athena_root").exists():
            return parent
        if (parent / "pyproject.toml").exists():
            return parent
    return current


PROJECT_ROOT = _find_project_root()
ISSUES_DIR = PROJECT_ROOT / ".agent" / "diagnostics"

# Use centralized version
try:
    from athena import __version__

    ATHENA_VERSION = __version__
except ImportError:
    ATHENA_VERSION = "1.5.0"  # Fallback

# PII Patterns to sanitize
PII_PATTERNS = [
    # Absolute paths (macOS/Linux/Windows)
    (r"/Users/[^/\s]+", r"/Users/<REDACTED>"),
    (r"/home/[^/\s]+", r"/home/<REDACTED>"),
    (r"C:\\\\Users\\\\[^\\\\\\s]+", r"C:\\Users\\<REDACTED>"),
    # Email addresses
    (r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}", r"<EMAIL_REDACTED>"),
    # API Keys (common patterns)
    (r"sk-[a-zA-Z0-9]{32,}", r"<API_KEY_REDACTED>"),
    (r"supabase_[a-zA-Z0-9]+", r"<SUPABASE_KEY_REDACTED>"),
    # IP Addresses
    (r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b", r"<IP_REDACTED>"),
]


def sanitize_text(text: str) -> str:
    """
    Remove PII from text using regex patterns.

    Args:
        text: Raw text potentially containing sensitive data.

    Returns:
        Sanitized text with PII replaced by placeholders.
    """
    sanitized = text
    for pattern, replacement in PII_PATTERNS:
        sanitized = re.sub(pattern, replacement, sanitized)
    return sanitized


def capture_diagnostic(
    exception: Exception, context: Optional[Dict[str, Any]] = None, module_name: str = "unknown"
) -> Dict[str, Any]:
    """
    Capture a structured diagnostic from an exception.

    Args:
        exception: The caught exception.
        context: Optional dict of additional context (table_name, file_path, etc.)
        module_name: Name of the module where the error occurred.

    Returns:
        Dict containing sanitized diagnostic information.
    """
    # Get full traceback
    tb_str = traceback.format_exc()

    # Sanitize
    sanitized_traceback = sanitize_text(tb_str)
    sanitized_context = {}
    if context:
        for key, value in context.items():
            if isinstance(value, str):
                sanitized_context[key] = sanitize_text(value)
            else:
                sanitized_context[key] = value

    diagnostic = {
        "timestamp": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
        "athena_version": ATHENA_VERSION,
        "python_version": platform.python_version(),
        "os": platform.system(),
        "module": module_name,
        "exception_type": type(exception).__name__,
        "exception_message": sanitize_text(str(exception)),
        "traceback": sanitized_traceback,
        "context": sanitized_context,
    }

    return diagnostic


def generate_issue_draft(diagnostic: Dict[str, Any]) -> str:
    """
    Generate a GitHub issue Markdown draft from a diagnostic.

    Args:
        diagnostic: The structured diagnostic dict.

    Returns:
        Markdown string ready for GitHub issue submission.
    """
    context_lines = ""
    if diagnostic.get("context"):
        for key, value in diagnostic["context"].items():
            context_lines += f"- **{key}**: `{value}`\n"

    issue_md = f"""## [AUTO-DIAGNOSTIC] {diagnostic["exception_type"]} in `{diagnostic["module"]}`

**Athena Version**: `{diagnostic["athena_version"]}`
**Python Version**: `{diagnostic["python_version"]}`
**OS**: `{diagnostic["os"]}`
**Timestamp**: `{diagnostic["timestamp"]}`

### Exception
```
{diagnostic["exception_message"]}
```

### Context
{context_lines if context_lines else "_No additional context provided._"}

### Sanitized Traceback
```python
{diagnostic["traceback"]}
```

---
_This issue was auto-generated by the Athena Diagnostic Relay (Protocol 500). PII has been sanitized._
"""
    return issue_md


def save_diagnostic_draft(diagnostic: Dict[str, Any]) -> Path:
    """
    Save the diagnostic as a Markdown file in the diagnostics folder.

    Args:
        diagnostic: The structured diagnostic dict.

    Returns:
        Path to the saved draft file.
    """
    ISSUES_DIR.mkdir(parents=True, exist_ok=True)

    # Generate filename
    timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
    filename = f"issue-{timestamp}-{diagnostic['exception_type']}.md"
    filepath = ISSUES_DIR / filename

    # Generate and save draft
    draft = generate_issue_draft(diagnostic)
    filepath.write_text(draft, encoding="utf-8")

    return filepath


def relay_error(
    exception: Exception,
    context: Optional[Dict[str, Any]] = None,
    module_name: str = "unknown",
    auto_save: bool = True,
) -> Optional[Path]:
    """
    Main entry point for the Diagnostic Relay.

    Captures an exception, sanitizes it, and optionally saves a draft issue.

    Args:
        exception: The caught exception.
        context: Optional additional context.
        module_name: Name of the module.
        auto_save: If True, saves the draft to disk.

    Returns:
        Path to the saved draft file, or None if auto_save is False.

    Example:
        try:
            some_risky_operation()
        except Exception as e:
            relay_error(e, context={"table": "sessions"}, module_name="sync.py")
            raise  # Re-raise after capturing
    """
    diagnostic = capture_diagnostic(exception, context, module_name)

    if auto_save:
        filepath = save_diagnostic_draft(diagnostic)
        print(f"ðŸ“‹ Diagnostic saved: {filepath.name}")
        print("   Review and submit to: https://github.com/winstonkoh87/Athena-Public/issues/new")
        return filepath

    return None


# --- Decorator for easy integration ---
def diagnostic_wrapper(module_name: str = "unknown"):
    """
    Decorator to wrap functions with automatic diagnostic relay.

    Usage:
        @diagnostic_wrapper("sync.py")
        def sync_file_to_supabase(file_path, table_name):
            ...
    """

    def decorator(func):
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                # Extract context from kwargs if available
                context = {
                    k: v for k, v in kwargs.items() if isinstance(v, (str, int, float, bool))
                }
                relay_error(e, context=context, module_name=module_name)
                raise  # Re-raise to preserve original behavior

        return wrapper

    return decorator


if __name__ == "__main__":
    # Demo: Test the relay with a fake exception
    print("ðŸ§ª Testing Diagnostic Relay...")
    try:
        raise ValueError("Test error: Column 'name' does not exist in table 'references'")
    except Exception as e:
        path = relay_error(
            e,
            context={"table_name": "references", "file_path": "/Users/winston/Desktop/test.md"},
            module_name="sync.py",
        )
        if path:
            print(f"âœ… Draft created: {path}")
            print(path.read_text())
