# Debug Session: React `useEffect` Race Condition

> **Context**: Debugging a flickering UI issue in a Next.js dashboard where data from a previous tab would briefly flash when switching tabs.
> **Date**: 2025-12-15
> **Mode**: `/think` (Triple Crown)

---

**User**: Hey Athena, I have a weird bug. When I switch from "Overview" to "Settings" in the dashboard, the "Overview" data flashes for a split second before the "Settings" data loads. I'm using a standard `useEffect` to fetch data.

**Athena**: [Λ+15] Analysis initiated. This sounds like a classic race condition or a stale state update. Let's look at the fetch logic.

**User**: Here's the snippet:

```javascript
useEffect(() => {
  setLoading(true);
  fetch(`/api/${tab}`).then(data => {
    setData(data);
    setLoading(false);
  });
}, [tab]);
```

**Athena**: [Λ+45] **DeepCode Analysis**

### 1. Diagnosis (The Skeptic)

The issue is that the `fetch` is asynchronous. If the user switches from Tab A to Tab B quickly:

1. Request A starts.
2. User switches to Tab B.
3. Request B starts.
4. Request B finishes (fast). UI updates to B.
5. Request A finishes (slow). UI updates to A (stale). -> **Flash/Incorrect Data**

### 2. Solution Architecture (The Architect)

We need to cancel the previous request or ignore its result if the component has unmounted or the dependency has changed.

### 3. Implementation (The Engineer)

Standard pattern: **Cleanup Function + Boolean Flag** (or `AbortController`).

**Proposed Fix (Boolean Flag Pattern)**:

```javascript
useEffect(() => {
  let isMounted = true; // 1. Track mount status
  setLoading(true);

  fetch(`/api/${tab}`).then(data => {
    if (isMounted) { // 2. Only update if still valid
      setData(data);
      setLoading(false);
    }
  });

  return () => { isMounted = false }; // 3. Cleanup on change
}, [tab]);
```

**User**: Does this work with `async/await` too?

**Athena**: Yes, but `useEffect` cleanup must remain synchronous.

**Refactor (AbortController - Modern Approach)**:

```javascript
useEffect(() => {
  const controller = new AbortController();
  setLoading(true);

  async function fetchData() {
    try {
      const res = await fetch(`/api/${tab}`, { signal: controller.signal });
      const data = await res.json();
      setData(data);
    } catch (err) {
      if (err.name !== 'AbortError') console.error(err);
    } finally {
      // Only unset loading if not aborted (optional, depends on UX)
      if (!controller.signal.aborted) setLoading(false);
    }
  }

  fetchData();

  return () => controller.abort(); // Cancel the network request
}, [tab]);
```

> **Result**: The `AbortController` approach is superior because it actually cancels the network request, saving bandwidth, rather than just ignoring the result.

**User**: Implemented the AbortController version. Bug is gone.

**Athena**: [Λ+5] Excellent. Added `Pattern: React Race Condition` to our knowledge graph for future reference.

---

*Generated by Athena Session Logger*
